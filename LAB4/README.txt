This is a short essay to explain the process of a CPU recieving a timer inturrupt and handling it.

_tinth: INTH thandler is a line of code in ts.s that allows the PC to handle the code meant to handle an inturrupt recieved from the PIC.  "_tinth" is the label that's allows the inturrupt vector to be assigned to the right handler function in C code in the main() function and "INTH thandler" calls a macro that saves the PROCs current stack context before changing the registers to execute the previously assigned function, thandler(), in kmode.

To make sure tinth() can execute correctly based on whether the running PROC is in Umode or in Kmode is by adding a variable to the PROC structure called "inkmode" which keeps track of whether the PROC is in Umode or in Kmode.  If inkmode is equal to 1, it is considered in Umode, and the value is incremented each time the PROC changes its execution location to one in Kmode, ie; when calling syscall() or when recieving an inturrupt, and it is decremented each time it exits the inturrupt handler's code or when it enters Umode.  In this specific program the tinth() function will only decrement the running PROC's allotted CPU usage time in Umode but not in Kmode.  This is to ensure that the PROC does not get switched when the kernel is handling an inturrupt and to ensure that the INTH and RET code does not push or pop registers into or out of the wrong PROC's memory location.

When a timer inturrupt occures, the PIC will send a signal to the CPU to notify it of an incomming inturrupt, which will then jump to the place in code the inturrupt's corrisponding vector was assigned to: INT thandler.  When the CPU goes into the INT code, it first saves the PROC's Umode context, its registers into the Umode stack and its place in code/segment in the PROC structure, before setting the registers up to execute in Kmode.  Then, from assembly, INT calls the handler assigned to the inturrupt, "thandler()".  When thandler() returns, INT calls _ireturn to check whether the running PROC was in Umode before handling the inturrupt, then restores its correct code context accordingly.
